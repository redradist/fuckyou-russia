import asyncio
import os
import re
import sys
import traceback
from typing import Union, Optional, Tuple, Callable, Awaitable

from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import Text
from aiogram.types import ContentType, ParseMode, Message
from aiogram.utils import executor
from telethon import TelegramClient
from phonenumbers.phonenumberutil import country_code_for_region
from telethon.errors import SessionPasswordNeededError, PhoneCodeExpiredError
from telethon.sessions import SQLiteSession
from src.database.database import async_db_session
from loader import dp, bot
from src.database.models import TelegramSession

import telegram_keyboard as kb
from states import User
from telegram_ban import report_channels

API_ID = int(os.environ['API_ID'])
API_HASH = os.environ['API_HASH']
BOT_TOKEN = os.environ['BOT_TOKEN']

user_code_fut = dict()
user_password_fut = dict()

code_pattern = r"(code|–∫–æ–¥)(?P<code>\d+)"
code_regex = re.compile(code_pattern)


class BotException(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

    def __repr__(self):
        return f"BotException({self.msg})"


async def get_session(user_name):
    sessions = await TelegramSession.filter_by_user_name(user_name)
    if len(sessions) > 0:
        return sessions[0].user_session
    else:
        return ''


async def create_or_update_session(user_name, user_session):
    await TelegramSession.create(user_name=user_name, user_session=user_session)
    user = await TelegramSession.get(1)
    return user.id


async def is_start_command(msg):
    return msg.is_command() or msg.text in [kb.msg_restart_ru, kb.msg_restart_ua, kb.msg_restart_en]


async def hello_help(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await msg.answer(
            f"–ü—Ä–∏–≤–µ—Ç, {msg.from_user.get_mention(as_html=True)} üëã!\n"
            f"–≠—Ç–æ—Ç —á–∞—Ç –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–ª–µ–≥—Ä–∞–º–º –∫–∞–Ω–∞–ª—ã –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—é—Ç –ª–æ–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –£–∫—Ä–∞–∏–Ω–µ, "
            f"–∞ —Ç–∞–∫–∂–µ –ø–ª–∞—Ç—è—Ç —Ç–µ—Ä—Ä–æ—Ä–∏—Å—Ç–∞–º –∑–∞ —Ç–µ—Ä—Ä–∞–∫—Ç—ã –≤ –£–∫—Ä–∞–∏–Ω–µ !\n",
            parse_mode=ParseMode.HTML,
            reply_markup=kb.menu_ru
        )
    elif locale.language == 'ua':
        await msg.answer(
            f"–ü—Ä–∏–≤—ñ—Ç, {msg.from_user.get_mention(as_html=True)} üëã!\n"
            f"–¶–µ–π —á–∞—Ç –¥–æ–∑–≤–æ–ª—è—î –∑–∞–±–ª–æ–∫—É–≤–∞—Ç–∏ —Ç–µ–ª–µ–≥—Ä–∞–º–º –∫–∞–Ω–∞–ª–∏ –∫–æ—Ç—Ä—ñ —Ä–æ–∑–ø–æ–≤—Å—é–¥–∂—É—é—Ç—å —Ö–∏–±–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –£–∫—Ä–∞—ó–Ω—É, "
            f"–∞ —Ç–∞–∫–æ–∂ –ø–ª–∞—Ç—è—Ç —Ç–µ—Ä–æ—Ä–∏—Å—Ç–∞–º –∑–∞ —Ç–µ—Ä–∞–∫—Ç–∏ –≤ –£–∫—Ä–∞—ó–Ω—ñ !\n",
            parse_mode=ParseMode.HTML,
            reply_markup=kb.menu_ua
        )
    else:
        await msg.answer(
            f"Hello, {msg.from_user.get_mention(as_html=True)} üëã!\n"
            f"This chat bot allows to block the telegram channels that spread misinformation about Ukraine "
            f"and pay terrorists for tract on Ukraine !\n",
            parse_mode=ParseMode.HTML,
            reply_markup=kb.menu_en
        )


async def press_button_start_again(msg):
    locale = msg.from_user.locale
    user_id = msg.from_user.id
    if locale.language == 'ru':
        await bot.send_message(user_id, f"–í—Ä–µ–º—è –≤—ã—à–ª–æ, –æ—Ç–ø—Ä–∞–≤—Ç–µ –∫–æ–º–∞–Ω–¥—É '–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ'")
    elif locale.language == 'ua':
        await bot.send_message(user_id, f"–í—Ä–µ–º—è –≤–∏–π—à–ª–æ, –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ –∫–æ–º–∞–Ω–¥—É '–ü–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É'")
    else:
        await bot.send_message(user_id, f"Timeout, press command 'Start againÔ∏è'")


async def enter_phone(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await msg.reply(
            f"–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞\n",
            parse_mode=ParseMode.HTML,
            reply_markup=kb.menu_ru
        )
    elif locale.language == 'ua':
        await msg.reply(
            f"–í–≤–µ–¥—ñ—Ç—å —Å–≤—ñ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞\n",
            parse_mode=ParseMode.HTML,
            reply_markup=kb.menu_ua
        )
    else:
        await msg.reply(
            f"Enter your phone number\n",
            parse_mode=ParseMode.HTML,
            reply_markup=kb.menu_en
        )


async def enter_phone_error_empty(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await bot.send_message(msg.from_user.id, f"–¢–µ–ª–µ—Ñ–æ–Ω—ã–π –Ω–æ–º–µ—Ä –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ü–∏—Ñ—Ä—ã !!")
    elif locale.language == 'ua':
        await bot.send_message(msg.from_user.id, f"–¢–µ–ª–µ—Ñ–æ–Ω–∏–π –Ω–æ–º–µ—Ä –ø–æ–≤–∏–Ω–µ–Ω –º—ñ—Å—Ç–∏—Ç–∏ —Ü–∏—Ñ—Ä–∏ !!")
    else:
        await bot.send_message(msg.from_user.id, f"Phone number should contains digits !!")


async def enter_phone_error_plus(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await bot.send_message(msg.from_user.id,
                               f"–¢–µ–ª–µ—Ñ–æ–Ω—ã–π –Ω–æ–º–µ—Ä –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å 13 —Å–∏–º–≤–æ–ª–æ–≤ –µ—Å–ª–∏ –æ–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å —Å–∏–º–≤–æ–ª–∞ '+' !!")
    elif locale.language == 'ua':
        await bot.send_message(msg.from_user.id,
                               f"–¢–µ–ª–µ—Ñ–æ–Ω–∏–π –Ω–æ–º–µ—Ä –ø–æ–≤–∏–Ω–µ–Ω –º–∞—Ç–∏ 13 —Å–∏–º–≤–æ–ª—ñ–≤ —è–∫—â–æ –≤—ñ–Ω –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ —Å–∏–º–≤–æ–ª—É '+' !!")
    else:
        await bot.send_message(msg.from_user.id,
                               f"Phone number should have size 13 symbols if it starts from symbol '+' !!")


async def enter_phone_error_3(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await bot.send_message(msg.from_user.id,
                               f"–¢–µ–ª–µ—Ñ–æ–Ω—ã–π –Ω–æ–º–µ—Ä –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å 12 —Å–∏–º–≤–æ–ª–æ–≤ –µ—Å–ª–∏ –æ–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å —Ü–∏—Ñ—Ä—ã '3' !!")
    elif locale.language == 'ua':
        await bot.send_message(msg.from_user.id,
                               f"–¢–µ–ª–µ—Ñ–æ–Ω–∏–π –Ω–æ–º–µ—Ä –ø–æ–≤–∏–Ω–µ–Ω –º–∞—Ç–∏ 12 —Å–∏–º–≤–æ–ª—ñ–≤ —è–∫—â–æ –≤—ñ–Ω –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ —Ü–∏—Ñ—Ä–∏ '3' !!")
    else:
        await bot.send_message(msg.from_user.id,
                               f"Phone number should have size 12 symbols if it starts from digit '3' !!")


async def enter_phone_error(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await bot.send_message(msg.from_user.id,
                               f"–¢–µ–ª–µ—Ñ–æ–Ω—ã–π –Ω–æ–º–µ—Ä –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å 11 —Å–∏–º–≤–æ–ª–æ–≤ –µ—Å–ª–∏ –æ–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∫–æ–¥–∞ —Å—Ç—Ä–∞–Ω—ã !!")
    elif locale.language == 'ua':
        await bot.send_message(msg.from_user.id,
                               f"–¢–µ–ª–µ—Ñ–æ–Ω–∏–π –Ω–æ–º–µ—Ä –ø–æ–≤–∏–Ω–µ–Ω –º–∞—Ç–∏ 11 —Å–∏–º–≤–æ–ª—ñ–≤ —è–∫—â–æ –≤—ñ–Ω –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ –∫–æ–¥–∞ –∫—Ä–∞—ó–Ω–∏ !!")
    else:
        await bot.send_message(msg.from_user.id,
                               f"Phone number should have size 11 symbols if it starts from country code !!")


async def enter_code_confirmation(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await bot.send_message(msg.from_user.id, f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –∫–æ–¥|–ö–æ–¥|. –î–ª—è –ø—Ä–∏–º–µ—Ä–∞: –∫–æ–¥213243 –∞–±–æ –ö–æ–¥213243")
    elif locale.language == 'ua':
        await bot.send_message(msg.from_user.id, f"–ë—É–¥—å-–¥–∞—Å–∫–∞ –≤–≤–µ–¥—ñ—Ç—å –∫–æ–¥ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —É —Ñ–æ—Ä–º–∞—Ç—ñ: –∫–æ–¥|–ö–æ–¥|. –î–ª—è –ø—Ä–∏–º–µ—Ä–∞: –∫–æ–¥213243 –∞–±–æ –ö–æ–¥213243")
    else:
        await bot.send_message(msg.from_user.id, f"Enter code confirmation in format: code|Code|. For example: code213243 or Code213243")


async def enter_password_confirmation(msg):
    locale = msg.from_user.locale
    user_id = msg.from_user.id
    if locale.language == 'ru':
        await bot.send_message(user_id, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–¥–∞, —É –≤–∞—Å –≤–∫–ª—é—á–µ–Ω–∞ Two Factor Autorization –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø–∞—Ä–æ–ª—å !!")
    elif locale.language == 'ua':
        await bot.send_message(user_id, f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ –∫–æ–¥—É, —É –≤–∞—Å –≤–∫–ª—é—á–µ–Ω–∞ Two Factor Autorization —Å–ø—Ä–æ–±—É–π—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø–∞—Ä–æ–ª—å !!")
    else:
        await bot.send_message(user_id, f"Error receiving code, you have Two Factor Autorization enabled try enter your password !!")


async def confirmation_code_error(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await bot.send_message(msg.from_user.id, f"–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—É—Å—Ç—ã–º !!")
    elif locale.language == 'ua':
        await bot.send_message(msg.from_user.id, f"–ö–æ–¥ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –Ω–µ –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ –ø—É—Å—Ç–∏–º !!")
    else:
        await bot.send_message(msg.from_user.id, f"Code confirmation shouldn't be empty !!")


async def confirmation_password_error(msg):
    locale = msg.from_user.locale
    if locale.language == 'ru':
        await bot.send_message(msg.from_user.id, f"–ü–∞—Ä–æ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—É—Å—Ç—ã–º !!")
    elif locale.language == 'ua':
        await bot.send_message(msg.from_user.id, f"–ü–∞—Ä–æ–ª—å –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –Ω–µ –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ –ø—É—Å—Ç–∏–º !!")
    else:
        await bot.send_message(msg.from_user.id, f"Password confirmation shouldn't be empty !!")


async def fuck_russia_channels(msg):
    locale = msg.from_user.locale
    user_id = msg.from_user.id
    if locale.language == 'ru':
        await bot.send_message(user_id, f"–í—ã –∑–∞–ª–æ–≥–∏–Ω–µ–Ω—ã, —Å–µ–π—á–∞—Å –≤—ã –≤—ã–µ–±–µ—Ç–µ —Ä–∞—à–∏—Å—Ç–∫–∏–µ —Ç–µ–ª–µ–≥—Ä–∞–º –∫–∞–Ω–∞–ª—ã !! –ë–ª–∞–≥–æ–¥–∞—Ä—é –∑–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–æ !!")
    elif locale.language == 'ua':
        await bot.send_message(user_id, f"–í–∏ –∑–∞–ª–æ–≥—ñ–Ω–µ–Ω—ñ, –∑–∞—Ä–∞–∑ –≤–∏ –≤–∏–µ–±–µ—Ç —Ä–∞—à–∏—Å—Ç–∫—ñ —Ç–µ–ª–µ–≥—Ä–∞–º –∫–∞–Ω–∞–ª–∏ !! –î—è–∫—É—é –∑–∞ —Å–ø—ñ–≤–ø—Ä–∞—Ü—é !!")
    else:
        await bot.send_message(user_id, f"You are logged in, now you will fuck russian telegram channels !! Thank you for your cooperation !!")



async def phone_validate_and_update(msg, phone):
    locale = msg.from_user.locale
    if len(phone) == 0:
        await enter_phone_error_empty(msg)
    elif phone[0] == '+':
        if len(phone) != 13:
            await enter_phone_error_plus(msg)
        else:
            return phone
    elif phone[0] == '3':
        phone = '+' + phone
        if len(phone) != 13:
            await enter_phone_error_3(msg)
        else:
            return phone
    else:
        if len(phone) == 10 and locale.territory is not None:
            phone = str(country_code_for_region(locale.territory)) + phone
        phone = '+3' + phone
        if len(phone) != 13:
            await enter_phone_error(msg)
        else:
            return phone


async def connect_using_phone(msg, state, phone):
    username = msg.from_user.mention
    client = TelegramClient(SQLiteSession(username), API_ID, API_HASH)
    try:
        await client.connect()
        if client.is_connected():
            if not await client.is_user_authorized():
                await User.Code.set()
                response = await client.send_code_request(phone)
                await enter_code_confirmation(msg)
                loop = asyncio.get_running_loop()
                code_fut = loop.create_future()
                user_code_fut[username] = code_fut
                code = await code_fut
                await client.sign_in(phone=phone, code=code, phone_code_hash=response.phone_code_hash)
            if await client.is_user_authorized():
                await User.Done.set()
                await fuck_russia_channels(msg)
                await report_channels(client, create_report_channels_callback(msg))
    except SessionPasswordNeededError as ex:
        print(f"ERROR: {ex}", file=sys.stderr)
        await User.Password.set()
        await enter_password_confirmation(msg)

        loop = asyncio.get_running_loop()
        password_fut = loop.create_future()
        user_password_fut[username] = password_fut
        password = await password_fut
        response = await client.sign_in(password=password)
        if await client.is_user_authorized():
            user = response
            await User.Done.set()
            await fuck_russia_channels(msg)
            await report_channels(client, create_report_channels_callback(msg))
    except Exception as ex:
        print(f"ERROR: {ex}", file=sys.stderr)
        traceback.print_stack(file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        user_id = msg.from_user.id
        await bot.send_message(user_id, f"ERROR: {ex}")
    finally:
        if client.is_connected():
            await client.disconnect()


async def send_code(msg, state, phone):
    username = msg.from_user.mention
    client = TelegramClient(SQLiteSession(username), API_ID, API_HASH)
    try:
        await client.connect()
        if client.is_connected():
            if not await client.is_user_authorized():
                await User.Code.set()
                response = await client.send_code_request(phone)
                await enter_code_confirmation(msg)
                async with state.proxy() as data:
                    data['phone_code_hash'] = response.phone_code_hash
                    print(f"phone = {phone}, phone_code_hash = {response.phone_code_hash}")
            else:
                await fuck_russia_channels(msg)
                await report_channels(client, create_report_channels_callback(msg))
    except Exception as ex:
        print(f"ERROR: {ex}", file=sys.stderr)
        traceback.print_stack(file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        user_id = msg.from_user.id
        await bot.send_message(user_id, f"ERROR: {ex}")
    finally:
        if client.is_connected():
            await client.disconnect()


async def connect_using_code(msg, phone, code, phone_code_hash):
    username = msg.from_user.mention
    client = TelegramClient(SQLiteSession(username), API_ID, API_HASH)
    try:
        await client.connect()
        if client.is_connected():
            if not await client.is_user_authorized():
                await client.sign_in(phone=phone, code=code, phone_code_hash=phone_code_hash)
                await User.Done.set()
                await fuck_russia_channels(msg)
                await report_channels(client, create_report_channels_callback(msg))
    except SessionPasswordNeededError as ex:
        print(f"ERROR: {ex}", file=sys.stderr)
        await User.Password.set()
        await enter_password_confirmation(msg)

        loop = asyncio.get_running_loop()
        password_fut = loop.create_future()
        user_password_fut[username] = password_fut
        password = await password_fut
        response = await client.sign_in(password=password)
        if await client.is_user_authorized():
            user = response
            await User.Done.set()
            await fuck_russia_channels(msg)
            await report_channels(client, create_report_channels_callback(msg))
    except Exception as ex:
        print(f"ERROR: {ex}", file=sys.stderr)
        traceback.print_stack(file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        user_id = msg.from_user.id
        await bot.send_message(user_id, f"ERROR: {ex}")
    finally:
        if client.is_connected():
            await client.disconnect()


async def connect_using_password(msg, state, phone, password):
    username = msg.from_user.mention
    client = TelegramClient(SQLiteSession(username), API_ID, API_HASH)
    try:
        await client.connect()
        if client.is_connected():
            if not await client.is_user_authorized():
                response = await client.sign_in(password=password)
                if await client.is_user_authorized():
                    user = response
                    await User.Done.set()
                    await fuck_russia_channels(msg)
                    await report_channels(client, create_report_channels_callback(msg))
    except Exception as ex:
        print(f"ERROR: {ex}", file=sys.stderr)
        traceback.print_stack(file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        user_id = msg.from_user.id
        await bot.send_message(user_id, f"ERROR: {ex}")
    finally:
        if client.is_connected():
            await client.disconnect()


def create_report_channels_callback(msg) -> Callable[[Union[Optional[str], Tuple[str, Exception]]], Awaitable[None]]:
    locale = msg.from_user.locale
    user_id = msg.from_user.id

    async def report_channels_callback(arg: Union[Optional[str], Tuple[str, Exception]]):
        if type(arg) == str:
            ch_name = arg
            if locale.language == 'ru':
                await bot.send_message(user_id, f"–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —Ä–µ–ø–æ—Ä—Ç –ø—Ä–æ {ch_name}")
            elif locale.language == 'ua':
                await bot.send_message(user_id, f"–£—Å–ø—ñ—à–Ω–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ —Ä–µ–ø–æ—Ä—Ç –ø—Ä–æ {ch_name}")
            else:
                await bot.send_message(user_id, f"Successfully reported about {ch_name}")
        elif type(arg) == tuple:
            ch_name, ex = arg
            if locale.language == 'ru':
                await bot.send_message(user_id, f"–û–®–ò–ë–ö–ê: –†–µ–ø–æ—Ä—Ç –ø—Ä–æ –∫–∞–Ω–∞–ª {ch_name}:\n{ex}")
            elif locale.language == 'ua':
                await bot.send_message(user_id, f"–ü–û–ú–ò–õ–ö–ê: –†–µ–ø–æ—Ä—Ç –ø—Ä–æ –∫–∞–Ω–∞–ª {ch_name}:\n{ex}")
            else:
                await bot.send_message(user_id, f"ERROR: Report about {ch_name}:\n{ex}")
        elif arg is None:
            if locale.language == 'ru':
                await bot.send_message(user_id, "–†–µ–ø–æ—Ä—Ç—ã –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ !!")
            elif locale.language == 'ua':
                await bot.send_message(user_id, "–†–µ–ø–æ—Ä—Ç–∏ –Ω–∞ –≤—Å—ñ –∫–∞–Ω–∞–ª–∏ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω—ñ —É—Å–ø—ñ—à–Ω–æ !!")
            else:
                await bot.send_message(user_id, "All channels reported successfully !!")

    return report_channels_callback


@dp.message_handler(commands='start',
                    state='*')
async def process_start_command(msg: Message):
    await User.Phone.set()
    await hello_help(msg)
    await enter_phone(msg)


@dp.message_handler(Text(equals=[kb.msg_restart_ru, kb.msg_restart_ua, kb.msg_restart_en], ignore_case=True),
                    state='*')
async def process_text_command(msg: Message, state: FSMContext):
    username = msg.from_user.mention
    if await is_start_command(msg):
        if username in user_code_fut:
            code_fut = user_code_fut[username]
            code_fut.cancel()

        if username in user_password_fut:
            password_fut = user_password_fut[username]
            password_fut.cancel()

        await User.Phone.set()
        await enter_phone(msg)


@dp.message_handler(state=User.Phone, content_types=ContentType.CONTACT)
async def process_phone(msg: Message, state: FSMContext):
    if not await is_start_command(msg):
        phone = msg.contact.phone_number
        phone = await phone_validate_and_update(msg, phone)
        if not phone:
            return

        print(f"Received phone = {phone}")
        async with state.proxy() as data:
            data['phone'] = phone

        # TODO: send_code do not work because using it creates separate client for sending code
        # See also the issue https://github.com/LonamiWebs/Telethon/issues/278 and other multiple errors
        # asyncio.create_task(send_code(msg, state, phone))
        asyncio.create_task(connect_using_phone(msg, state, phone))


@dp.message_handler(state=User.Phone, content_types=ContentType.TEXT)
async def process_phone_text(msg: Message, state: FSMContext):
    if not await is_start_command(msg):
        phone = msg.text
        phone = await phone_validate_and_update(msg, phone)
        if not phone:
            return

        print(f"Received phone = {phone}")
        async with state.proxy() as data:
            data['phone'] = phone

        # TODO: send_code do not work because using it creates separate client for sending code
        # See also the issue https://github.com/LonamiWebs/Telethon/issues/278 and other multiple errors
        # asyncio.create_task(send_code(msg, state, phone))
        asyncio.create_task(connect_using_phone(msg, state, phone))


@dp.message_handler(state=User.Code)
async def process_code(msg: Message, state: FSMContext):
    if not await is_start_command(msg):
        code_match = code_regex.match(msg.text.lower().replace(' ', ''))
        if not code_match:
            await confirmation_code_error(msg)
        else:
            code = code_match.group('code')
            print(f"Received code = {code}")
            username = msg.from_user.mention
            if username in user_code_fut:
                code_fut = user_code_fut[username]
                code_fut.set_result(code)
            else:
                async with state.proxy() as data:
                    data['code'] = code
                    phone = data['phone']
                    phone_code_hash = data['phone_code_hash']
                    print(f"phone = {phone}, phone_code_hash = {phone_code_hash}")

                    asyncio.create_task(connect_using_code(msg, phone, code, phone_code_hash))


@dp.message_handler(state=User.Password)
async def process_password(msg: Message, state: FSMContext):
    if not await is_start_command(msg):
        password = msg.text
        print(f"Received password")
        if len(password) == 0:
            await confirmation_password_error(msg)
        else:
            username = msg.from_user.mention
            if username in user_password_fut:
                password_fut = user_password_fut[username]
                password_fut.set_result(password)
            else:
                phone = None
                async with state.proxy() as data:
                    data['password'] = password
                    phone = data['phone']
                await connect_using_password(msg, state, phone, password)


async def main():
    await async_db_session.init()
    await async_db_session.create_all()
    await dp.skip_updates()
    await dp.start_polling()


if __name__ == '__main__':
    asyncio.run(main())
